# 0. pentest mobile

![image](https://hackmd.io/_uploads/rJL0NBsdR.png)

## một số khái niệm

### AVD và ADB

#### ADB

- ADB (Android Debug Bridge): Là một công cụ dòng lệnh cho phép bạn giao tiếp với một thiết bị Android. ADB cung cấp nhiều tính năng hữu ích như cài đặt và gỡ bỏ ứng dụng, gỡ lỗi ứng dụng, truy cập vào shell của thiết bị, và truyền tệp giữa máy tính và thiết bị Android. Nó thường được sử dụng trong quá trình phát triển và kiểm thử ứng dụng để kiểm tra và khắc phục sự cố.
  **AVD thì sẽ sử dụng ADB tại đường dẫn** `C:\Users\HP\AppData\Local\Android\Sdk\platform-tools`

![image](https://hackmd.io/_uploads/BkXJ0F5u0.png)

![image](https://hackmd.io/_uploads/SkEPgc9u0.png)

![image](https://hackmd.io/_uploads/HyozWqq_A.png)

- Truy cập shell qua adb: `adb -s <DEVICE_NAME> shell`
- Lấy thông tin phiên bản Android và API level:

```bash
getprop ro.build.version.release
getprop ro.build.version.sdk
```

- Lấy thông tin kiến trúc CPU: `getprop ro.product.cpu.abi`

![image](https://hackmd.io/_uploads/BkVlfqcdC.png)

![image](https://hackmd.io/_uploads/SyTU795OR.png)

![image](https://hackmd.io/_uploads/BkE9Eq5OC.png)

![image](https://hackmd.io/_uploads/ryRTLccOR.png)

![image](https://hackmd.io/_uploads/BkFUF59uR.png)

#### AVD

- AVD (Android Virtual Device): Là một cấu hình thiết bị mô phỏng được tạo ra bởi Android Emulator. AVD cho phép bạn chạy và kiểm thử ứng dụng Android trong một môi trường mô phỏng mà không cần phải sử dụng thiết bị vật lý. Bạn có thể tùy chỉnh cấu hình của AVD để mô phỏng các thiết bị với các phiên bản Android khác nhau, kích thước màn hình, độ phân giải, và các thông số phần cứng khác.

![image](https://hackmd.io/_uploads/HyR5g8cuC.png)

- các thiết bị có biểu tượng Play Store sẽ là thiết bị chưa root. Để kiểm thử bảo mật thì chúng ta cần sử dụng thiết bị root.

mở emulator tại `C:\Users\{user}\AppData\Local\Android\Sdk\emulator`

![image](https://hackmd.io/_uploads/BkWc1c5uR.png)

### SSL pinning

- SSL pinning là một kỹ thuật bảo mật trong ứng dụng di động và các ứng dụng web để tăng cường đáng tin cậy và ngăn chặn các cuộc tấn công trung gian (man-in-the-middle attacks).

- Khi một ứng dụng thực hiện kết nối bảo mật (như HTTPS) với một máy chủ, thông thường nó sẽ xác thực chứng chỉ SSL/TLS của máy chủ bằng cách so sánh với danh sách chứng chỉ tin cậy. Tuy nhiên, SSL pinning làm cho quá trình này nghiêm ngặt hơn bằng cách ràng buộc ứng dụng chỉ tin tưởng vào một số chứng chỉ cụ thể hoặc khóa công khai được chỉ định trước.

![image](https://hackmd.io/_uploads/B17f0XiO0.png)

![image](https://hackmd.io/_uploads/S1FTyEiuC.png)

![image](https://hackmd.io/_uploads/BJ-b1UjdC.png)

browser không có ssl pinning như mobile app

- Trình duyệt web: Trình duyệt web được thiết kế để truy cập đến hàng triệu trang web khác nhau, mỗi trang web có thể sử dụng các chứng chỉ SSL từ nhiều nhà cung cấp khác nhau. Việc áp dụng SSL pinning cho từng trang web sẽ trở nên rất phức tạp và khó quản lý.
- Ứng dụng di động: Các ứng dụng di động thường kết nối đến một số ít các máy chủ cụ thể, do đó dễ dàng hơn để thực hiện SSL pinning nhằm tăng cường bảo mật.

Trong các ứng dụng di động, việc kiểm tra SSL thường được thực hiện ở hai mức độ: mức hệ điều hành (OS) và mức ứng dụng. Đây là cách mà quá trình này hoạt động:

1. Kiểm tra SSL tại mức hệ điều hành (OS)
   Khi một ứng dụng di động thực hiện một kết nối HTTPS, hệ điều hành sẽ thực hiện các kiểm tra bảo mật cơ bản sau: - Xác thực chứng chỉ SSL: Hệ điều hành kiểm tra chứng chỉ SSL của máy chủ để đảm bảo rằng nó được ký bởi một tổ chức chứng chỉ (CA) đáng tin cậy nằm trong danh sách CA gốc của hệ điều hành. - Kiểm tra chuỗi chứng chỉ (certificate chain): Hệ điều hành xác thực chuỗi chứng chỉ từ chứng chỉ của máy chủ đến CA gốc, đảm bảo tính toàn vẹn và hợp lệ của chuỗi chứng chỉ.
2. Kiểm tra SSL tại mức ứng dụng (SSL Pinning)
   Ứng dụng di động có thể thực hiện thêm một lớp kiểm tra bảo mật thông qua SSL pinning. Đây là các bước thực hiện: - Xác thực chứng chỉ cụ thể hoặc khóa công khai (public key): Ứng dụng sẽ kiểm tra chứng chỉ hoặc khóa công khai của máy chủ so với các chứng chỉ hoặc khóa công khai đã được "pin" trước đó trong mã nguồn của ứng dụng. - Tùy chỉnh logic kiểm tra: Nhà phát triển có thể tùy chỉnh logic kiểm tra này để đảm bảo rằng ứng dụng chỉ kết nối với các máy chủ đáng tin cậy.

- Lợi ích của việc kiểm tra SSL hai lần
  1. Bảo mật tăng cường: - Kiểm tra hệ điều hành: Đảm bảo rằng kết nối cơ bản là an toàn và sử dụng chứng chỉ hợp lệ từ một CA đáng tin cậy. - SSL pinning tại ứng dụng: Thêm một lớp bảo mật bổ sung bằng cách xác thực chứng chỉ cụ thể hoặc khóa công khai, ngăn chặn các tấn công MITM ngay cả khi có chứng chỉ giả mạo nhưng hợp lệ.
     2.Phòng ngừa tấn công MITM: - Hệ điều hành: Bảo vệ chống lại các chứng chỉ không hợp lệ hoặc không tin cậy. - Ứng dụng: Ngăn chặn các tấn công MITM ngay cả khi kẻ tấn công có chứng chỉ từ một CA được tin cậy nhưng không phải là chứng chỉ được ứng dụng pinning.

### Hook

Khi một chương trình khởi động thì các biến, hằng, chuỗi ký tự, hàm,... sẽ được tải vào bộ nhớ của thiết bị.

![image](https://hackmd.io/_uploads/Sya6OcjuR.png)

Khi đọc được lời gọi hàm hoặc đọc dữ liệu từ một biến, hệ thống sẽ tìm đến địa chỉ của hàm hoặc biến đó trong bộ nhớ để lấy dữ liệu ra. Kỹ thuật hook sẽ nhắm vào khoảng thời gian trước khi hệ thống đọc được dữ liệu thành công. Thư viện hook sẽ khiến cho hệ thống đọc sai địa chỉ lưu dữ liệu và các chỉ thị của hàm, từ đó khiến cho chương trình hoạt động sai so với thiết kế.

![image](https://hackmd.io/_uploads/HyXlKqiuA.png)

Hook trong bối cảnh di động (mobile) là một kỹ thuật mà bạn chặn và điều khiển luồng thực thi của một ứng dụng di động, là một kỹ thuật được sử dụng để chặn, theo dõi, hoặc thay đổi hành vi của các hàm hoặc phương thức trong một ứng dụng hoặc hệ thống mà không cần phải sửa đổi mã nguồn ban đầu

1. Mục đích của Hook:
   - Gỡ lỗi: Giúp các nhà phát triển theo dõi và sửa lỗi trong ứng dụng.
   - Phân tích bảo mật: Giúp các nhà nghiên cứu bảo mật kiểm tra và tìm lỗ hổng bảo mật trong ứng dụng.
   - Thay đổi hành vi ứng dụng: Cho phép thay đổi cách mà một ứng dụng hoạt động mà không cần truy cập vào mã nguồn của nó.
2. Cách hoạt động của Hook:

   - Hooking các hàm API: Bạn có thể chặn các lời gọi tới các hàm API của hệ điều hành hoặc thư viện để thay đổi tham số, thay đổi giá trị trả về, hoặc thực hiện các hành động bổ sung.
   - Hooking các hàm trong ứng dụng: Bạn có thể chặn các lời gọi tới các hàm trong ứng dụng để theo dõi hoặc thay đổi hành vi của ứng dụng.
     - Chặn và Giám sát: Hook cho phép bạn chặn các cuộc gọi hàm hoặc phương thức và giám sát dữ liệu truyền qua chúng. Điều này có thể hữu ích trong việc kiểm tra cách một ứng dụng xử lý dữ liệu nhạy cảm hoặc xác thực người dùng.
     - Thay đổi Hành Vi: Bằng cách sử dụng hook, bạn có thể thay đổi hành vi của ứng dụng. Ví dụ, bạn có thể thay đổi đầu vào hoặc đầu ra của một hàm, hoặc thay thế một hàm bằng một hàm khác.

3. Công cụ Hooking phổ biến:
   - Frida: Như đã đề cập trước đó, Frida là một công cụ mạnh mẽ cho phép bạn chèn mã JavaScript vào ứng dụng để thực hiện các hành động hooking.

### Frida

https://www.youtube.com/watch?v=S-Vq5BDADGY&t=351s
https://www.youtube.com/watch?v=GWgr0xk8DTM

- Frida là một công cụ mạnh mẽ được sử dụng cho phân tích bảo mật, kiểm thử xâm nhập (pentest) và phân tích động (dynamic analysis) của ứng dụng. Dưới đây là một số điểm chính về Frida:
  - Mục đích: Frida được thiết kế để giúp các nhà phát triển và các nhà nghiên cứu bảo mật kiểm tra, phân tích và thao tác với ứng dụng trên các nền tảng khác nhau như Android, iOS, Windows, macOS, và Linux.
  - Chức năng: Frida cho phép bạn chèn mã JavaScript vào các quá trình đang chạy để can thiệp và theo dõi hoạt động của ứng dụng. Bạn có thể sử dụng Frida để thực hiện các tác vụ như giám sát hàm gọi, thay đổi tham số, theo dõi dữ liệu và các hoạt động khác mà không cần truy cập vào mã nguồn của ứng dụng.
  - Cách hoạt động: Frida sử dụng các script JavaScript để thao tác với ứng dụng mục tiêu. Bạn có thể viết các script này để thực hiện các hành động cụ thể như hook vào các hàm API, giám sát và thay đổi giá trị biến, và nhiều hơn nữa. Frida cung cấp một API mạnh mẽ cho việc tạo các script này.

Frida chia thành client và server:

- Frida client: cài ở máy tính của mình, giúp chúng ta điều khiển Frida server.
- Frida server: cài trong giả lập và thiết bị android.

về android hooking với Frida, vậy hooking là gì? → là chúng ta cung cấp cho Frida sử dụng các Javascript API để tương tác trực tiếp với Java functions, để thực hiện các thao tác như: lấy dữ liệu hay thay đổi luồng hoạt động của ứng dụng theo ý định

- vậy chúng ta có thể dùng Frida để bypass SSL Pinning

### Decompile file APK

GUI: apktook-gui, jadx-gui, bytecode-viewer

### proxy

- cấu hình burp suit lắng nghe trên cổng 8888

![image](https://hackmd.io/_uploads/HJt86cq_0.png)

- trên điện thoại download chứng chỉ CA

![image](https://hackmd.io/_uploads/ByuM7icuR.png)

- đổi extension từ .der sang .cer

![image](https://hackmd.io/_uploads/Sy3Lmj9_C.png)

- thêm chứng chỉ CA

![image](https://hackmd.io/_uploads/BkYPQi5OA.png)

![image](https://hackmd.io/_uploads/H1Bhmj5uC.png)

![image](https://hackmd.io/_uploads/BymKmsquR.png)

- chúng ta thêm chứng chỉ kiểu này sẽ chỉ vào chứng chỉ của người dùng tự sẽ không vào được root certificate chứng chỉ của hệ thống -> vì vậy chúng ta cần có 1 điện thoại samsung đã root
- Kể từ phiên bản Android 10 trở lên thì các chứng chỉ có thời hạn quá lâu (lớn hơn 39 tháng) sẽ không được chấp nhận nữa, và các ứng dụng sẽ chỉ chấp nhận chứng chỉ của hệ thống (root) mà thôi. Do đó chứng chỉ của Burp sẽ không thể sử dụng được nữa, chúng ta bắt buộc phải tự tạo ra chứng chỉ riêng

- mình cấu hình proxy qua wifi

![image](https://hackmd.io/_uploads/H18IBiqdR.png)

![image](https://hackmd.io/_uploads/S1-DHo9OR.png)

- vào chrome trên điện thoại search bluecyber

![image](https://hackmd.io/_uploads/SyADro9dC.png)

- Kết quả bắt request bằng Burpsuite:

![image](https://hackmd.io/_uploads/rkG81scuC.png)

![image](https://hackmd.io/_uploads/Byt_1i5OA.png)

![image](https://hackmd.io/_uploads/BkAFys5d0.png)

![image](https://hackmd.io/_uploads/H1ljxo5O0.png)

- Với các ứng dụng không sử dụng SSL/TLS pining thì chúng ta có thể dễ dàng bắt được các gói tin theo cách trên. Còn với các ứng dụng có sử dụng SSL/TLS pining thì chúng ta phải thực hiện bypass mới có thể bắt được

### Bytecode Viewer

![image](https://hackmd.io/_uploads/HJBskcodR.png)

Bytecode viewer là công cụ cho phép chúng ta đồng thời xem được code java và code smali. Khi mở tệp tin apk bằng bytecode viewer, công cụ sẽ tiến hành dịch ngược và biểu diễn code theo cấu trúc thư mục. Tuy nhiên nếu mã nguồn đã được làm rối (obfuscate) thì việc tìm đúng tệp tin mình cần sẽ khó khăn hơn nhiều.

Cái hay của Bytecode Viewer là nó cho biết code smali nào ứng với code java. Bằng cách này chúng ta có thể biết chính xác tệp tin code smali nếu muốn sửa code bằng apktool.

- Smali là ngôn ngữ lắp ráp (assembly language) được sử dụng để lập trình cho các tập tin Dalvik bytecode trong hệ điều hành Android.
- Dalvik bytecode là định dạng mã được máy ảo Dalvik (Dalvik Virtual Machine - DVM) và Android Runtime (ART) sử dụng để thực thi các ứng dụng Android. Smali cung cấp một cách để làm việc trực tiếp với các tập tin .dex (Dalvik Executable) và thực hiện các thao tác chỉnh sửa mã bytecode.

Các Khái Niệm Cơ Bản về Smali

- Tập tin .smali: Đây là các tập tin văn bản chứa mã Smali. Chúng tương ứng với các lớp Java đã được biên dịch thành bytecode Dalvik.

- Cấu trúc lệnh Smali:
  - .class: Định nghĩa một lớp.
  - .super: Định nghĩa lớp cha của lớp hiện tại.
  - .method: Định nghĩa một phương thức.
  - .field: Định nghĩa một biến trường (field).

![image](https://hackmd.io/_uploads/HyizGqo_0.png)

### mô hình code trong android

- Một ứng dụng Android có thể được tạo thành từ 2 ngôn ngữ lập trình khác nhau, ví dụ như Java và Native code. Các ngôn ngữ khác như Kotlin, Flutter theo mình tìm hiểu thì cũng có thể làm được tương tự như Java. Java, Kotlin, Flutter sẽ đảm nhiệm phần chính trong việc tạo ra giao diện của ứng dụng, còn phần code Native C/C++ sẽ làm các phần xử lý tầng thấp hơn, giao tiếp với phần cứng và hệ điều hành nhiều hơn.

![image](https://hackmd.io/_uploads/SJgFv5odA.png)

- Để liên kết được phần code Native và phần code còn lại cần có một thành phần chuyên biệt
- Với Java thì thành phần này được gọi là JNI - Java Native Interface.

![image](https://hackmd.io/_uploads/BJR3w9oOR.png)

Khi ứng dụng hoạt động, những phần code bằng Java vẫn sẽ được chạy trong Dalvik VM. Còn phần code Native sẽ hoạt động như một thư viện độc lập, sẽ làm những công việc xử lý của riêng nó và trả lại kết quả về Dalvik VM thông qua JNI.

![image](https://hackmd.io/_uploads/r1NMdcj_A.png)

## Tham khảo

- https://viblo.asia/p/cai-dat-moi-truong-pentest-android-tren-windows-phan-1-aWj53jpwl6m#_viet-script-khoi-dong-nhanh-avd-5
- https://hackmd.io/@janlele91/BJ20xGWFn
